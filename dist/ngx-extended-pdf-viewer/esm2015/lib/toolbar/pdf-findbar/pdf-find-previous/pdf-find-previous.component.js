import { Component } from '@angular/core';
import * as i0 from "@angular/core";
export class PdfFindPreviousComponent {
    constructor() { }
    ngOnInit() {
    }
}
/** @nocollapse */ PdfFindPreviousComponent.ɵfac = function PdfFindPreviousComponent_Factory(t) { return new (t || PdfFindPreviousComponent)(); };
/** @nocollapse */ PdfFindPreviousComponent.ɵcmp = /** @pureOrBreakMyCode */ i0.ɵɵdefineComponent({ type: PdfFindPreviousComponent, selectors: [["pdf-find-previous"]], decls: 5, vars: 0, consts: [["type", "button", "id", "findPrevious", "title", "Find the previous occurrence of the phrase", "data-l10n-id", "find_previous", 1, "toolbarButton"], ["viewBox", "0 0 24 24", 2, "width", "24px", "height", "24px"], ["fill", "currentColor", "d", "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"], ["data-l10n-id", "find_previous_label"]], template: function PdfFindPreviousComponent_Template(rf, ctx) { if (rf & 1) {
        i0.ɵɵelementStart(0, "button", 0);
        i0.ɵɵnamespaceSVG();
        i0.ɵɵelementStart(1, "svg", 1);
        i0.ɵɵelement(2, "path", 2);
        i0.ɵɵelementEnd();
        i0.ɵɵnamespaceHTML();
        i0.ɵɵelementStart(3, "span", 3);
        i0.ɵɵtext(4, "Previous");
        i0.ɵɵelementEnd();
        i0.ɵɵelementEnd();
    } }, styles: ["button.toolbarButton#findPrevious[_ngcontent-%COMP%]{margin-top:0}"] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(PdfFindPreviousComponent, [{
        type: Component,
        args: [{
                selector: 'pdf-find-previous',
                templateUrl: './pdf-find-previous.component.html',
                styleUrls: ['./pdf-find-previous.component.css']
            }]
    }], function () { return []; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGRmLWZpbmQtcHJldmlvdXMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWV4dGVuZGVkLXBkZi12aWV3ZXIvc3JjL2xpYi90b29sYmFyL3BkZi1maW5kYmFyL3BkZi1maW5kLXByZXZpb3VzL3BkZi1maW5kLXByZXZpb3VzLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1leHRlbmRlZC1wZGYtdmlld2VyL3NyYy9saWIvdG9vbGJhci9wZGYtZmluZGJhci9wZGYtZmluZC1wcmV2aW91cy9wZGYtZmluZC1wcmV2aW91cy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFVLE1BQU0sZUFBZSxDQUFDOztBQU9sRCxNQUFNLE9BQU8sd0JBQXdCO0lBRW5DLGdCQUFnQixDQUFDO0lBRWpCLFFBQVE7SUFDUixDQUFDOzttSEFMVSx3QkFBd0I7MEdBQXhCLHdCQUF3QjtRQ1ByQyxpQ0FLRztRQUNELG1CQUF3RDtRQUF4RCw4QkFBd0Q7UUFDdEQsMEJBQThGO1FBQ2hHLGlCQUFNO1FBQ04sb0JBQXlDO1FBQXpDLCtCQUF5QztRQUFBLHdCQUFRO1FBQUEsaUJBQU87UUFDMUQsaUJBQVM7O3VGREhJLHdCQUF3QjtjQUxwQyxTQUFTO2VBQUM7Z0JBQ1QsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IsV0FBVyxFQUFFLG9DQUFvQztnQkFDakQsU0FBUyxFQUFFLENBQUMsbUNBQW1DLENBQUM7YUFDakQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdwZGYtZmluZC1wcmV2aW91cycsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3BkZi1maW5kLXByZXZpb3VzLmNvbXBvbmVudC5odG1sJyxcclxuICBzdHlsZVVybHM6IFsnLi9wZGYtZmluZC1wcmV2aW91cy5jb21wb25lbnQuY3NzJ11cclxufSlcclxuZXhwb3J0IGNsYXNzIFBkZkZpbmRQcmV2aW91c0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkgeyB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gIH1cclxuXHJcbn1cclxuIiwiPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJcclxuICBpZD1cImZpbmRQcmV2aW91c1wiXHJcbiAgY2xhc3M9XCJ0b29sYmFyQnV0dG9uXCJcclxuICB0aXRsZT1cIkZpbmQgdGhlIHByZXZpb3VzIG9jY3VycmVuY2Ugb2YgdGhlIHBocmFzZVwiXHJcbiAgZGF0YS1sMTBuLWlkPVwiZmluZF9wcmV2aW91c1wiXHJcbiAgPlxyXG4gIDxzdmcgc3R5bGU9XCJ3aWR0aDoyNHB4O2hlaWdodDoyNHB4XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgPHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGQ9XCJNMTUuNDEsMTYuNThMMTAuODMsMTJMMTUuNDEsNy40MUwxNCw2TDgsMTJMMTQsMThMMTUuNDEsMTYuNThaXCIgLz5cclxuICA8L3N2Zz5cclxuICA8c3BhbiBkYXRhLWwxMG4taWQ9XCJmaW5kX3ByZXZpb3VzX2xhYmVsXCI+UHJldmlvdXM8L3NwYW4+XHJcbjwvYnV0dG9uPlxyXG4iXX0=